# memo 的原理

memo 内部统计其上游依赖:memo 或信号,做成一个 map ,key 是上游依赖,value 是上一次上游的计算结果.

每次向 memo 索取结果,都会去遍历上游依赖的最新计算结果,与缓存结果是否不同,如果不同,则更新缓存并计算.如果相同,返回上一次 memo 计算的结果.

- 如果上游是信号,则可以直接判断.
- 如果上游是 memo,则向这个 memo 索取值,重复这一过程,直到最顶层的信号.
  - 所以必须是无循环的图结构,即中间可能存在钻石结构,例如:a<-b1<-c,a<-b2<-c,a 若为 memo,只计算一次.又如果 b1,b2 依赖了非 memo 的函数 a1,a1 不会进入依赖关系,所以会多次执行,如果每次计算结果不一样,则会存在问题.

memo 内部只使用了 != 作为不同的判断,即存在对于复合结构,只是址判断.

因为 memo 的参数函数多是临场定义的,如果返回是否复合结构且深层结构不变,可以自己在这个函数里优化.

memo 返回的电线函数,带有可判断是否被 memo 修饰过的标识,即如果再作不必要的包装,可以直接返回.
